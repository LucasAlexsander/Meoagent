"use client";
import {
  useReactAriaPopover
} from "./chunk-JBPODFPT.mjs";

// src/use-popover.ts
import { useOverlayTriggerState } from "@react-stately/overlays";
import { useFocusRing } from "@react-aria/focus";
import { useOverlayTrigger, ariaHideOutside } from "@react-aria/overlays";
import { mapPropsVariants } from "@nextui-org/system";
import { getArrowPlacement, getShouldUseAxisPlacement } from "@nextui-org/aria-utils";
import { popover } from "@nextui-org/theme";
import { mergeProps, mergeRefs, useLayoutEffect } from "@react-aria/utils";
import { createDOMRef } from "@nextui-org/react-utils";
import { clsx, dataAttr } from "@nextui-org/shared-utils";
import { useId, useMemo, useCallback, useImperativeHandle, useRef } from "react";
function usePopover(originalProps) {
  var _a, _b;
  const [props, variantProps] = mapPropsVariants(originalProps, popover.variantKeys);
  const {
    ref,
    as,
    children,
    state: stateProp,
    triggerRef: triggerRefProp,
    scrollRef,
    isOpen,
    defaultOpen,
    onOpenChange,
    shouldFlip = true,
    containerPadding = 12,
    shouldBlockScroll = false,
    portalContainer,
    placement: placementProp = "top",
    triggerType = "dialog",
    showArrow = false,
    offset = 7,
    crossOffset = 0,
    isKeyboardDismissDisabled,
    motionProps,
    className,
    classNames,
    onClose,
    ...otherProps
  } = props;
  const Component = as || "div";
  const popoverId = useId();
  const popoverRef = useRef(null);
  const domTriggerRef = useRef(null);
  const triggerRef = triggerRefProp || domTriggerRef;
  const disableAnimation = (_a = originalProps.disableAnimation) != null ? _a : false;
  useImperativeHandle(
    ref,
    () => createDOMRef(popoverRef)
  );
  const innerState = useOverlayTriggerState({
    isOpen,
    defaultOpen,
    onOpenChange: (isOpen2) => {
      onOpenChange == null ? void 0 : onOpenChange(isOpen2);
      if (!isOpen2) {
        onClose == null ? void 0 : onClose();
      }
    }
  });
  const state = stateProp || innerState;
  const {
    popoverProps,
    underlayProps,
    arrowProps,
    placement: ariaPlacement
  } = useReactAriaPopover(
    {
      triggerRef,
      popoverRef,
      placement: placementProp,
      offset,
      scrollRef,
      crossOffset,
      shouldFlip,
      containerPadding,
      isKeyboardDismissDisabled
    },
    state
  );
  const { triggerProps } = useOverlayTrigger({ type: triggerType }, state, triggerRef);
  const { isFocusVisible, isFocused, focusProps } = useFocusRing();
  const slots = useMemo(
    () => popover({
      ...variantProps
    }),
    [...Object.values(variantProps)]
  );
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
  const getPopoverProps = (props2 = {}) => ({
    ref: popoverRef,
    ...mergeProps(popoverProps, otherProps, props2),
    id: popoverId
  });
  const getDialogProps = (props2 = {}) => ({
    "data-open": dataAttr(state.isOpen),
    "data-focus": dataAttr(isFocused),
    "data-focus-visible": dataAttr(isFocusVisible),
    "data-placement": getArrowPlacement(ariaPlacement, placementProp),
    ...mergeProps(focusProps, props2),
    className: slots.base({ class: clsx(baseStyles, props2.className) }),
    style: {
      outline: "none"
    }
  });
  const placement = useMemo(
    () => getShouldUseAxisPlacement(ariaPlacement, placementProp) ? ariaPlacement : placementProp,
    [ariaPlacement, placementProp]
  );
  const getTriggerProps = useCallback(
    (props2 = {}, _ref = null) => {
      return {
        ...mergeProps(triggerProps, props2),
        className: slots.trigger({ class: clsx(classNames == null ? void 0 : classNames.trigger, props2.className) }),
        ref: mergeRefs(_ref, triggerRef),
        "aria-controls": popoverId,
        "aria-haspopup": "dialog"
      };
    },
    [isOpen, popoverId, state, triggerProps, triggerRef]
  );
  const getBackdropProps = useCallback(
    (props2 = {}) => ({
      className: slots.backdrop({ class: classNames == null ? void 0 : classNames.backdrop }),
      onClick: () => state.close(),
      ...underlayProps,
      ...props2
    }),
    [slots, classNames, underlayProps]
  );
  const getArrowProps = useCallback(
    () => ({
      className: slots.arrow({ class: classNames == null ? void 0 : classNames.arrow }),
      "data-placement": getArrowPlacement(ariaPlacement, placementProp),
      ...arrowProps
    }),
    [arrowProps, ariaPlacement, placementProp, slots, classNames]
  );
  useLayoutEffect(() => {
    if (state.isOpen && popoverRef.current) {
      return ariaHideOutside([popoverRef.current]);
    }
  }, [state.isOpen, popoverRef]);
  return {
    Component,
    children,
    classNames,
    showArrow,
    triggerRef,
    placement,
    portalContainer,
    isOpen: state.isOpen,
    onClose: state.close,
    disableAnimation,
    shouldBlockScroll,
    backdrop: (_b = originalProps.backdrop) != null ? _b : "transparent",
    motionProps,
    focusProps,
    getBackdropProps,
    getPopoverProps,
    getTriggerProps,
    getArrowProps,
    getDialogProps
  };
}

export {
  usePopover
};
